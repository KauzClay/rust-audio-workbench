var searchIndex = {};
searchIndex["hound"] = {"doc":"Hound, a wav encoding and decoding library.","items":[[3,"WavReader","hound","A reader that reads the WAVE format from the underlying reader.",null,null],[3,"WavIntoSamples","","An iterator that yields samples of type `S` read from a `WavReader`.",null,null],[3,"WavSamples","","An iterator that yields samples of type `S` read from a `WavReader`.",null,null],[3,"SampleWriter16","","A writer that specifically only writes integer samples of 16 bits per sample.",null,null],[3,"WavWriter","","A writer that accepts samples and writes the WAVE format.",null,null],[3,"WavSpec","","Specifies properties of the audio data.",null,null],[12,"channels","","The number of channels.",0,null],[12,"sample_rate","","The number of samples per second.",0,null],[12,"bits_per_sample","","The number of bits per sample.",0,null],[12,"sample_format","","Whether the wav's samples are float or integer values.",0,null],[4,"SampleFormat","","Specifies whether a sample is stored as an \"IEEE Float\" or an integer.",null,null],[13,"Float","","Wave files with the `WAVE_FORMAT_IEEE_FLOAT` format tag store samples as floating point values.",1,null],[13,"Int","","Wave files with the `WAVE_FORMAT_PCM` format tag store samples as integer values.",1,null],[4,"Error","","The error type for operations on `WavReader` and `WavWriter`.",null,null],[13,"IoError","","An IO error occured in the underlying reader or writer.",2,null],[13,"FormatError","","Ill-formed WAVE data was encountered.",2,null],[13,"TooWide","","The sample has more bits than the destination type.",2,null],[13,"UnfinishedSample","","The number of samples written is not a multiple of the number of channels.",2,null],[13,"Unsupported","","The format is not supported.",2,null],[13,"InvalidSampleFormat","","The sample format is different than the destination format.",2,null],[5,"read_wave_header","","Reads the RIFF WAVE header, returns the supposed file size.",null,{"inputs":[{"name":"r"}],"output":{"generics":["u64"],"name":"result"}}],[11,"new","","Attempts to create a reader that reads the WAVE format.",3,{"inputs":[{"name":"r"}],"output":{"generics":["wavreader"],"name":"result"}}],[11,"spec","","Returns information about the WAVE file.",3,{"inputs":[{"name":"self"}],"output":{"name":"wavspec"}}],[11,"samples","","Returns an iterator over all samples.",3,{"inputs":[{"name":"self"}],"output":{"name":"wavsamples"}}],[11,"into_samples","","Same as `samples`, but takes ownership of the `WavReader`.",3,{"inputs":[{"name":"self"}],"output":{"name":"wavintosamples"}}],[11,"duration","","Returns the duration of the file in samples.",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"len","","Returns the number of values that the sample iterator will yield.",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"into_inner","","Destroys the `WavReader` and returns the underlying reader.",3,{"inputs":[{"name":"self"}],"output":{"name":"r"}}],[11,"seek","","Seek to the given time within the file.",3,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"open","","Attempts to create a reader that reads from the specified file.",3,{"inputs":[{"name":"p"}],"output":{"generics":["wavreader"],"name":"result"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"size_hint","","",4,null],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"size_hint","","",5,null],[11,"new","","Creates a writer that writes the WAVE format to the underlying writer.",6,{"inputs":[{"name":"w"},{"name":"wavspec"}],"output":{"generics":["wavwriter"],"name":"result"}}],[11,"write_sample","","Writes a single sample for one channel.",6,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"get_i16_writer","","Create an efficient writer that writes 16-bit integer samples only.",6,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"samplewriter16"}}],[11,"flush","","Updates the WAVE header and flushes the underlying writer.",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"finalize","","Updates the WAVE header (which requires knowing all samples).",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"spec","","Returns information about the WAVE file being written.",6,{"inputs":[{"name":"self"}],"output":{"name":"wavspec"}}],[11,"duration","","Returns the duration of the file written so far, in samples.",6,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"len","","Returns the number of samples in the file written so far.",6,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"drop","","",6,{"inputs":[{"name":"self"}],"output":null}],[11,"create","","Creates a writer that writes the WAVE format to a file.",6,{"inputs":[{"name":"p"},{"name":"wavspec"}],"output":{"generics":["wavwriter"],"name":"result"}}],[11,"append","","Creates a writer that appends samples to an existing file.",6,{"inputs":[{"name":"p"}],"output":{"generics":["wavwriter"],"name":"result"}}],[11,"new_append","","Creates a writer that appends samples to an existing file stream.",6,{"inputs":[{"name":"w"}],"output":{"generics":["wavwriter"],"name":"result"}}],[11,"write_sample","","Writes a single sample for one channel.",7,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"write_sample_unchecked","","Like `write_sample()`, but does not perform a bounds check when writing to the internal buffer.",7,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"flush","","Flush the internal buffer to the underlying writer.",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"Result","","A type for results generated by Hound where the error type is hard-wired.",null,null],[8,"Sample","","A type that can be used to represent audio samples.",null,null],[10,"write","","Writes the audio sample to the WAVE data chunk.",8,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u16"}],"output":{"name":"result"}}],[10,"read","","Reads the audio sample from the WAVE data chunk.",8,{"inputs":[{"name":"r"},{"name":"sampleformat"},{"name":"u16"},{"name":"u16"}],"output":{"name":"result"}}],[10,"as_i16","","Cast the sample to a 16-bit sample.",8,{"inputs":[{"name":"self"}],"output":{"name":"i16"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"sampleformat"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"sampleformat"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"wavspec"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"wavspec"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"wavspec"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"description","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"error"}}]],"paths":[[3,"WavSpec"],[4,"SampleFormat"],[4,"Error"],[3,"WavReader"],[3,"WavSamples"],[3,"WavIntoSamples"],[3,"WavWriter"],[3,"SampleWriter16"],[8,"Sample"]]};
searchIndex["raw"] = {"doc":"This is documentation for the raw crate.","items":[[0,"tempo","raw","Structs for accessing audio data in terms of musical concepts of time signature and tempo",null,null],[3,"TimeSignature","raw::tempo","",null,null],[3,"Tempo","","",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",0,{"inputs":[{"name":"u16"},{"name":"u16"}],"output":{"name":"self"}}],[11,"common_time","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"cut_time","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",1,{"inputs":[{"name":"timesignature"},{"name":"f64"}],"output":{"name":"self"}}],[11,"beat_length_sec","","",1,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"measure_length_sec","","",1,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"outline","raw","The core trait for implementing structs that represent audio data",null,null],[6,"Sample","raw::outline","A type to represent the size of one unit of audio data",null,null],[8,"Time","","moments and durations are represented by types that implement Time. Convertible to/from the equivalent number of samples. This allows time to be represented in different ways, e.g. measures+beats, seconds+millis, etc.",null,null],[10,"to_samples","","the number of samples that takes up the same amount of time as self",2,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"u64"}}],[10,"from_samples","","return a copy representing the length of time in num_samples",2,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u32"}],"output":{"name":"self"}}],[8,"Clip","","The core functionality required by any struct that is to hold/represent audio data",null,null],[10,"duration","","returns an iterator over this clip. returns the duration of this clip in number of samples.",3,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[10,"sample_rate","","returns the number of samples per second of this clip.",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"get","","get the sample at a point. Returns 0 if out of range.",3,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"sample"}}],[11,"interpolate","","interpolate between samples calculates the value at (sample_at + fractional) where 0.0 <= fractional < 1.0 the current interpolation function is linear; this should definitely use a better method eventually.",3,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"f64"}],"output":{"generics":["sample"],"name":"option"}}],[8,"Filter","","Any filter-style modification of audio data can be achieved by implementing structs following this trait",null,null],[10,"apply_sample","","",4,{"inputs":[{"name":"self"},{"name":"c"},{"name":"u64"},{"name":"u64"}],"output":null}],[11,"apply","","",4,{"inputs":[{"name":"self"},{"name":"c"},{"name":"s"},{"name":"t"}],"output":null}],[8,"AudioReader","","A trait for reading various audio files into compliant structures for manipulation in raw",null,null],[16,"Reader","","",5,null],[10,"read","","Converts an n-channel audio file into a vector of n reference-counted SampleArrays. Returns None upon failure.",5,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[8,"AudioWriter","","A trait for writing raw clips into various audio files",null,null],[16,"Writer","","",6,null],[10,"write","","Writes a Clip to a specified audio file",6,null],[0,"samplearray","raw","An clip implementation to hold audio data in a vector",null,null],[3,"SampleArray","raw::samplearray","A Clip Implementation that maintains audio data as a vector of Samples (see outline.rs:Sample) A common use for this object would be to hold the raw data, which you then reference throughout a project.",null,null],[12,"sample_rate","","",7,null],[12,"samples","","",7,null],[11,"new","","",7,{"inputs":[{"name":"u32"},{"generics":["sample"],"name":"vec"}],"output":{"name":"self"}}],[11,"duration","","returns the duration in samples.",7,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"sample_rate","","returns the number of samples per second of this clip.",7,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get","","get the sample at a point. Returns 0 for out-of-bounds access.",7,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"sample"}}],[0,"wavreader","raw","An implementation of our AudioReader and AudioWriter Traits using the Hound Wav crate",null,null],[0,"compounds","","Various Clip implementations that allow for joining and selecting sub sections",null,null],[3,"Subclip","raw::compounds","A struct used to represent a subset of audio data within a larger set via reference. Good for working with smaller chunks of data out of a SampleArray.",null,null],[3,"Concat","","A struct used to represent the joining of two Clip objects. Good for chaining together SubClips.",null,null],[3,"Reverse","","A simple struct to represent the reverse of a clip.",null,null],[11,"new","","The split time (start_time + duration_time) must be within the duration of the clip, else None is returned.",8,{"inputs":[{"generics":["clip"],"name":"arc"},{"name":"s"},{"name":"t"}],"output":{"generics":["arc"],"name":"option"}}],[11,"from_start","","Returns a SubClip from the beginning of the source clip to a specified time into the clip.",8,{"inputs":[{"generics":["clip"],"name":"arc"},{"name":"t"}],"output":{"generics":["arc"],"name":"option"}}],[11,"to_end","","Returns a SubClip from the specified start time to the end of the source clip.",8,{"inputs":[{"generics":["clip"],"name":"arc"},{"name":"t"}],"output":{"generics":["arc"],"name":"option"}}],[11,"split","","Returns two SubClips, one from the beginning of the source clip to the split point, and one from the split point to the end of the source clip.",8,{"inputs":[{"generics":["clip"],"name":"arc"},{"name":"t"}],"output":{"name":"option"}}],[11,"duration","","returns an iterator over this clip. returns the duration in samples.",8,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"sample_rate","","returns the number of samples per second of this clip.",8,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get","","get the sample at a point.",8,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"sample"}}],[11,"new","","The two clips to be joined must use the same sample rate, or else None is returned.",9,{"inputs":[{"generics":["clip"],"name":"arc"},{"generics":["clip"],"name":"arc"}],"output":{"generics":["arc"],"name":"option"}}],[11,"duration","","returns an iterator over this clip. returns the duration in samples.",9,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"sample_rate","","returns the number of samples per second of this clip.",9,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get","","get the sample at a point.",9,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"sample"}}],[11,"new","","",10,{"inputs":[{"generics":["clip"],"name":"arc"}],"output":{"name":"self"}}],[11,"duration","","returns the duration in samples.",10,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"sample_rate","","returns the number of samples per second of this clip.",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"get","","get the sample at a point. Samples are 'got' by inverting the sample_at index. EX: sample_at of 0 returns Sample N, sample_at of 1 returns Sample N-1, etc.",10,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"sample"}}],[0,"track","raw","Track struct that is used to maintain various clips assosiated with each other",null,null],[3,"Track","raw::track","A struct to represent a track containing a left and right channel. In future iterations, Track will be able to handle N channels.",null,null],[11,"new","","Creates a new, empty clip with a given name and sample rate.",11,{"inputs":[{"name":"string"},{"name":"u32"}],"output":{"name":"self"}}],[11,"sample_rate","","",11,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"name","","",11,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"insert_mono","","Inserts a Clip into self, shifting later clips by the inserted clip's duration.",11,{"inputs":[{"name":"self"},{"generics":["clip"],"name":"arc"},{"name":"t"}],"output":{"name":"bool"}}],[11,"insert_stereo","","Inserts two clips corresponding to left and right into the track. Clips do not need to be the same length. The clips will start at the same position and the shorter clip is padded with 0s to the duration of the longer clip",11,{"inputs":[{"name":"self"},{"generics":["clip"],"name":"arc"},{"generics":["clip"],"name":"arc"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"duration","","Returns the duration of the entire Track. If the mono and stero channels have different durations, the longer one is returned.",11,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"left_channel_as_clip","","",11,{"inputs":[{"name":"self"}],"output":{"generics":["clip"],"name":"arc"}}],[11,"right_channel_as_clip","","",11,{"inputs":[{"name":"self"}],"output":{"generics":["clip"],"name":"arc"}}],[0,"rawcli","raw","A simple command line interface for demo purposes",null,null],[3,"RawCliEnvironment","raw::rawcli","",null,null],[11,"new","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"enter_loop","","",12,{"inputs":[{"name":"self"},{"name":"r"},{"name":"w"}],"output":null}]],"paths":[[3,"TimeSignature"],[3,"Tempo"],[8,"Time"],[8,"Clip"],[8,"Filter"],[8,"AudioReader"],[8,"AudioWriter"],[3,"SampleArray"],[3,"Subclip"],[3,"Concat"],[3,"Reverse"],[3,"Track"],[3,"RawCliEnvironment"]]};
initSearch(searchIndex);
